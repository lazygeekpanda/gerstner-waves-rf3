(self.webpackChunkgerstner_waves_rf3=self.webpackChunkgerstner_waves_rf3||[]).push([[651],{6725:(e,n,t)=>{"use strict";t.d(n,{A:()=>c});t(5043);var r=t(7528);const o={black:"#0C0F13",accent:"#F5B82E",bg:"#f5f5f5"};var i;const s=t(6712).Ay.div(i||(i=(0,r.A)(["\n  height: 100vh;\n  background-color: ",";\n\n  overflow: hidden;\n"])),o.bg);var a=t(579);const c=e=>{let{children:n}=e;return(0,a.jsx)(s,{children:n})}},5953:(e,n,t)=>{"use strict";t.d(n,{A:()=>l});t(5043);var r=t(4672),o=t(7),i=t(579);var s,a=t(7528);const c=t(6712).Ay.div(s||(s=(0,a.A)(["\n  width: 100%;\n  height: 100%;\n\n  background-color: #f5f5f5;\n"]))),l=e=>{let{children:n}=e;return(0,i.jsx)(c,{children:(0,i.jsxs)(r.Hl,{camera:{position:[75,25,25]},children:[(0,i.jsx)(o.N,{minDistance:15,maxDistance:150,maxPolarAngle:Math.PI/2.5}),n,null]})})}},540:(e,n,t)=>{"use strict";t.d(n,{A:()=>a});var r=t(5043),o=t(1483),i=t(579);const s=()=>(0,i.jsx)(i.Fragment,{children:(0,i.jsx)(o.m,{distance:45e4,sunPosition:[1e3,1e3,8e3],inclination:10,turbidity:.5})}),a=(0,r.memo)(s)},4686:(e,n,t)=>{"use strict";t.d(n,{A:()=>f});var r=t(5043),o=t(7051),i=t(3986),s=t(9204),a=t(4672),c=t(579);const l=["model"],d=(0,r.forwardRef)(((e,n)=>{let{model:r}=e,d=(0,i.A)(e,l);const u=(0,a.pn)(s.w,t(7699)("./".concat(r)));return(0,c.jsx)("primitive",(0,o.A)({ref:n,object:u},d))})),u=(0,r.memo)(d),f=e=>{let{getWaveInfo:n}=e;const t=r.useRef(),o=r.useRef();return(0,a.j$)((e=>{let{clock:r}=e;const i=n(0,0,r.getElapsedTime()),s=n(0,256,r.getElapsedTime());null!==t&&void 0!==t&&t.current&&null!==o&&void 0!==o&&o.current&&(o.current.position.set(1.15*-s.x,s.y,256),t.current.position.set(i.x,i.y+7,i.z),t.current.lookAt(o.current.position))})),(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)("mesh",{ref:o,children:[(0,c.jsx)("planeBufferGeometry",{args:[256,256]}),(0,c.jsx)("meshStandardMaterial",{opacity:0,transparent:!0})]}),(0,c.jsx)(u,{ref:t,model:"ship.fbx",scale:[.5,.5,.5]})]})}},1944:(e,n,t)=>{"use strict";t.d(n,{A:()=>l});var r=t(7051),o=t(5043),i=t(9408),s=t(4672),a=t(9838);var c=t(579);(0,s.X$)({Water:a.E});const l=e=>{let{wireframe:n,size:a,waveA:l,waveB:d,waveC:u}=e;const f=(0,o.useRef)(),v=(0,s.yk)((e=>e.gl)),m=(0,s.pn)(i.TextureLoader,t(7413));m.wrapS=m.wrapT=i.RepeatWrapping;const w=(0,o.useCallback)((e=>{e.uniforms.waveA={value:[Math.sin(l.direction*Math.PI/180),Math.cos(l.direction*Math.PI/180),l.steepness,l.wavelength]},e.uniforms.waveB={value:[Math.sin(d.direction*Math.PI/180),Math.cos(d.direction*Math.PI/180),d.steepness,d.wavelength]},e.uniforms.waveC={value:[Math.sin(u.direction*Math.PI/180),Math.cos(u.direction*Math.PI/180),u.steepness,u.wavelength]},e.vertexShader="\nuniform mat4 textureMatrix;\nuniform float time;\n\nvarying vec4 mirrorCoord;\nvarying vec4 worldPosition;\n\n#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n\nuniform vec4 waveA;\nuniform vec4 waveB;\nuniform vec4 waveC;\n\nvec3 GerstnerWave (vec4 wave, vec3 p) {\n    float steepness = wave.z;\n    float wavelength = wave.w;\n    float k = 2.0 * PI / wavelength;\n    float c = sqrt(9.8 / k);\n    vec2 d = normalize(wave.xy);\n    float f = k * (dot(d, vec2(p.x, p.y)) - c * time);\n    float a = steepness / k;\n\n    return vec3(\n        d.x * (a * cos(f)),\n        d.y * (a * cos(f)),\n        a * sin(f)\n    );\n}\n\nvoid main() {\n    mirrorCoord = modelMatrix * vec4( position, 1.0 );\n    worldPosition = mirrorCoord.xyzw;\n    mirrorCoord = textureMatrix * mirrorCoord;\n\n    vec3 gridPoint = position.xyz;\n    vec3 tangent = vec3(1, 0, 0);\n    vec3 binormal = vec3(0, 0, 1);\n    vec3 p = gridPoint;\n    p += GerstnerWave(waveA, gridPoint);\n    p += GerstnerWave(waveB, gridPoint);\n    p += GerstnerWave(waveC, gridPoint);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( p.x, p.y, p.z, 1.0);\n\n    #include <beginnormal_vertex>\n    #include <defaultnormal_vertex>\n    #include <logdepthbuf_vertex>\n    #include <fog_vertex>\n    #include <shadowmap_vertex>\n}\n",e.fragmentShader="\nuniform sampler2D mirrorSampler;\nuniform float alpha;\nuniform float time;\nuniform float size;\nuniform float distortionScale;\nuniform sampler2D normalSampler;\nuniform vec3 sunColor;\nuniform vec3 sunDirection;\nuniform vec3 eye;\nuniform vec3 waterColor;\n\nvarying vec4 mirrorCoord;\nvarying vec4 worldPosition;\n\nuniform float offsetX;\nuniform float offsetZ;\n\nvec4 getNoise( vec2 uv ) {\n    vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n    vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n    vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n    vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n    vec4 noise = texture2D( normalSampler, uv0 ) +\n        texture2D( normalSampler, uv1 ) +\n        texture2D( normalSampler, uv2 ) +\n        texture2D( normalSampler, uv3 );\n    return noise * 0.5 - 1.0;\n}\n\nvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n    vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n    float direction = max( 0.0, dot( eyeDirection, reflection ) );\n    specularColor += pow( direction, shiny ) * sunColor * spec;\n    diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n}\n\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n\nvoid main() {\n\n    #include <logdepthbuf_fragment>\n\n    vec4 noise = getNoise( (worldPosition.xz) + vec2(offsetX/12.25,offsetZ/12.25) * size );\n    vec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n    vec3 diffuseLight = vec3(0.0);\n    vec3 specularLight = vec3(0.0);\n\n    vec3 worldToEye = eye-worldPosition.xyz;\n    vec3 eyeDirection = normalize( worldToEye );\n    sunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n    float distance = length(worldToEye);\n\n    vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n    vec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n    float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n    float rf0 = 0.3;\n    float reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n    vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n    vec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n    vec3 outgoingLight = albedo;\n    gl_FragColor = vec4( outgoingLight, alpha );\n\n    #include <tonemapping_fragment>\n    #include <fog_fragment>\n}\n",e.uniforms.size.value=0}),[l,d,u]),h=(0,o.useMemo)((()=>new i.PlaneGeometry(a,a,a/4,a/4)),[a]),p=(0,o.useMemo)((()=>({textureWidth:256,textureHeight:256,waterNormals:m,sunDirection:new i.Vector3,side:i.DoubleSide,waterColor:"#102E4A",sunColor:"#eb8934",distortionScale:8,fog:void 0,format:v.outputEncoding,onBeforeCompile:w})),[m,l,d,u]);return(0,o.useEffect)((()=>{if(!f.current)return;f.current.material.wireframe=n}),[a,n,l,d,u]),(0,s.j$)((e=>{let{clock:n}=e;if(!f.current)return;const t=f.current.material;t.uniforms.time.value=n.getElapsedTime(),t.onBeforeCompile=w})),(0,c.jsx)("water",{ref:f,args:[h,(0,r.A)({},p)],"rotation-x":-Math.PI/2,position:[0,2,0]})}},9651:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>g});var r,o=t(5043),i=t(6725),s=t(5953),a=t(540),c=t(1944),l=t(4686),d=t(7528);const u=t(6712).Ay.div(r||(r=(0,d.A)(["\n  position: absolute;\n  bottom: 20px;\n  left: 20px;\n\n  padding: 15px;\n\n  background-color: #fff;\n\n  z-index: 9;\n"]))),f=(e,n,t)=>{const r=e,o=9.81*Math.pow(t/(2*Math.PI),2);return{direction:r,steepness:n/o,wavelength:o}};var v=t(9408),m=t(579);const w=(0,o.createContext)({waveA:{direction:0,steepness:0,wavelength:100},waveB:{direction:0,steepness:0,wavelength:100},waveC:{direction:0,steepness:0,wavelength:100},weatherForecast:{swellDirection:0,swellHeight:0,swellMeanPeriod:0,firstSwellDirection:0,firstSwellHeight:0,firstSwellMeanPeriod:0,secondSwellDirection:0,secondSwellHeight:0,secondSwellMeanPeriod:0},getWaveInfo:(e,n,t)=>new v.Vector3}),h=e=>{let{children:n}=e;const[t,r]=(0,o.useState)({direction:0,steepness:0,wavelength:100}),[i,s]=(0,o.useState)({direction:0,steepness:0,wavelength:50}),[a,c]=(0,o.useState)({direction:0,steepness:0,wavelength:25}),[l,d]=(0,o.useState)({swellDirection:0,swellHeight:0,swellMeanPeriod:0,firstSwellDirection:0,firstSwellHeight:0,firstSwellMeanPeriod:0,secondSwellDirection:0,secondSwellHeight:0,secondSwellMeanPeriod:0});(0,o.useEffect)((()=>{u()}),[]);const u=()=>{const e={swellDirection:310,swellHeight:.3,swellMeanPeriod:12,firstSwellDirection:270,firstSwellHeight:.3,firstSwellMeanPeriod:5,secondSwellDirection:310,secondSwellHeight:1.2,secondSwellMeanPeriod:10};d(e),r(f(e.swellDirection,e.swellHeight,e.swellMeanPeriod)),s(f(e.firstSwellDirection,e.firstSwellHeight,e.firstSwellMeanPeriod)),c(f(e.secondSwellDirection,e.secondSwellHeight,e.secondSwellMeanPeriod))};return(0,m.jsx)(w.Provider,{value:{waveA:t,waveB:i,waveC:a,weatherForecast:l,getWaveInfo:(e,n,r)=>{const o=new v.Vector3,s=new v.Vector3(1,0,0),c=new v.Vector3(0,0,1);return[t,i,a].forEach((t=>{const i=2*Math.PI/t.wavelength,a=Math.sqrt(9.8/i),l=new v.Vector2(Math.sin(t.direction*Math.PI/180),-Math.cos(t.direction*Math.PI/180)),d=i*(l.dot(new v.Vector2(e,n))-a*r),u=t.steepness/i;o.x+=l.x*(u*Math.cos(d)),o.y+=u*Math.sin(d),o.z+=l.y*(u*Math.cos(d)),s.x+=-l.x*l.x*(t.steepness*Math.sin(d)),s.y+=l.x*(t.steepness*Math.cos(d)),s.z+=-l.x*l.y*(t.steepness*Math.sin(d)),c.x+=-l.x*l.y*(t.steepness*Math.sin(d)),c.y+=l.y*(t.steepness*Math.cos(d)),c.z+=-l.y*l.y*(t.steepness*Math.sin(d))})),o}},children:n})},p=()=>{const{waveA:e,waveB:n,waveC:t,weatherForecast:r,getWaveInfo:d}=(0,o.useContext)(w);return(0,m.jsxs)(i.A,{children:[(0,m.jsx)(u,{children:(0,m.jsxs)("div",{children:[(0,m.jsx)("strong",{children:"TODO:"})," Get forecast from API"]})}),(0,m.jsxs)(s.A,{children:[(0,m.jsx)("ambientLight",{intensity:.15,position:[100,100,100]}),(0,m.jsx)("pointLight",{position:[100,100,100],intensity:.5}),(0,m.jsx)(a.A,{}),(0,m.jsx)(l.A,{getWaveInfo:d}),(0,m.jsx)(c.A,{waveA:e,waveB:n,waveC:t,wireframe:!1,size:1024})]})]})},g=()=>(0,m.jsx)(m.Fragment,{children:(0,m.jsx)(h,{children:(0,m.jsx)(p,{})})})},7699:(e,n,t)=>{var r={"./ship.fbx":7611};function o(e){var n=i(e);return t(n)}function i(e){if(!t.o(r,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return r[e]}o.keys=function(){return Object.keys(r)},o.resolve=i,e.exports=o,o.id=7699},7611:(e,n,t)=>{"use strict";e.exports=t.p+"static/media/ship.679585528f34ff916505.fbx"},7413:(e,n,t)=>{"use strict";e.exports=t.p+"static/media/waternormals.537ec85b965d414829ab.jpg"}}]);
//# sourceMappingURL=651.12dbdb3e.chunk.js.map