"use strict";(self.webpackChunkgerstner_waves_rf3=self.webpackChunkgerstner_waves_rf3||[]).push([[840],{5840:function(e,n,r){r.r(n),r.d(n,{default:function(){return S}});var t,i,o=r(2791),a=r(7972),l=r(168),c=r(5751),s=r(9020),u=r(1758),v=c.ZP.div(t||(t=(0,l.Z)(["\n  height: calc(100vh - ",");\n  background-color: ",";\n\n  overflow: hidden;\n"])),s.Z.header,u.Z.bg),f=r(184),m=function(e){var n=e.children;return(0,f.jsx)(v,{children:n})},d=r(3285),p=r(3520),g=function(e){var n=e.children,r=o.useRef(),t=(0,d.Ky)().camera;return o.useEffect((function(){t.position.set(-25,15,-25)}),[]),(0,f.jsxs)(f.Fragment,{children:[(0,f.jsx)(p.z,{ref:r,minDistance:15,maxDistance:150,maxPolarAngle:Math.PI/2.5}),n]})},h=r(2362),x=function(){return(0,f.jsx)(h.j,{className:"stats-wrapper"})},w=c.ZP.div(i||(i=(0,l.Z)(["\n  width: 100%;\n  height: 100%;\n\n  background-color: #f5f5f5;\n"]))),b=function(e){var n=e.children;return(0,f.jsx)(w,{children:(0,f.jsxs)(d.Xz,{children:[(0,f.jsx)(g,{children:n}),(0,f.jsx)(x,{})]})})},C=r(4671),y=function(){return(0,f.jsx)(f.Fragment,{children:(0,f.jsx)(C.q,{distance:45e4,sunPosition:[1e3,1e3,8e3],inclination:10,turbidity:.5})})},_=(0,o.memo)(y),M=r(1413),P=r(7760),D=r(1190);(0,d.l7)({Water:D.B});var z=function(e){var n=e.wireframe,t=e.size,i=e.waveA,a=e.waveB,l=e.waveC,c=(0,o.useRef)(),s=(0,d.Ky)((function(e){return e.gl})),u=(0,d.U2)(P.TextureLoader,r(2410));u.wrapS=u.wrapT=P.RepeatWrapping;var v=(0,o.useCallback)((function(e){e.uniforms.waveA={value:[Math.sin(i.direction*Math.PI/180),Math.cos(i.direction*Math.PI/180),i.steepness,i.wavelength]},e.uniforms.waveB={value:[Math.sin(a.direction*Math.PI/180),Math.cos(a.direction*Math.PI/180),a.steepness,a.wavelength]},e.uniforms.waveC={value:[Math.sin(l.direction*Math.PI/180),Math.cos(l.direction*Math.PI/180),l.steepness,l.wavelength]},e.vertexShader="\nuniform mat4 textureMatrix;\nuniform float time;\n\nvarying vec4 mirrorCoord;\nvarying vec4 worldPosition;\n\n#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n\nuniform vec4 waveA;\nuniform vec4 waveB;\nuniform vec4 waveC;\n\nvec3 GerstnerWave (vec4 wave, vec3 p) {\n    float steepness = wave.z;\n    float wavelength = wave.w;\n    float k = 2.0 * PI / wavelength;\n    float c = sqrt(9.8 / k);\n    vec2 d = normalize(wave.xy);\n    float f = k * (dot(d, vec2(p.x, p.y)) - c * time);\n    float a = steepness / k;\n\n    return vec3(\n        d.x * (a * cos(f)),\n        d.y * (a * cos(f)),\n        a * sin(f)\n    );\n}\n\nvoid main() {\n    mirrorCoord = modelMatrix * vec4( position, 1.0 );\n    worldPosition = mirrorCoord.xyzw;\n    mirrorCoord = textureMatrix * mirrorCoord;\n\n    vec3 gridPoint = position.xyz;\n    vec3 tangent = vec3(1, 0, 0);\n    vec3 binormal = vec3(0, 0, 1);\n    vec3 p = gridPoint;\n    p += GerstnerWave(waveA, gridPoint);\n    p += GerstnerWave(waveB, gridPoint);\n    p += GerstnerWave(waveC, gridPoint);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( p.x, p.y, p.z, 1.0);\n\n    #include <beginnormal_vertex>\n    #include <defaultnormal_vertex>\n    #include <logdepthbuf_vertex>\n    #include <fog_vertex>\n    #include <shadowmap_vertex>\n}\n",e.fragmentShader="\nuniform sampler2D mirrorSampler;\nuniform float alpha;\nuniform float time;\nuniform float size;\nuniform float distortionScale;\nuniform sampler2D normalSampler;\nuniform vec3 sunColor;\nuniform vec3 sunDirection;\nuniform vec3 eye;\nuniform vec3 waterColor;\n\nvarying vec4 mirrorCoord;\nvarying vec4 worldPosition;\n\nuniform float offsetX;\nuniform float offsetZ;\n\nvec4 getNoise( vec2 uv ) {\n    vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n    vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n    vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n    vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n    vec4 noise = texture2D( normalSampler, uv0 ) +\n        texture2D( normalSampler, uv1 ) +\n        texture2D( normalSampler, uv2 ) +\n        texture2D( normalSampler, uv3 );\n    return noise * 0.5 - 1.0;\n}\n\nvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n    vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n    float direction = max( 0.0, dot( eyeDirection, reflection ) );\n    specularColor += pow( direction, shiny ) * sunColor * spec;\n    diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n}\n\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n\nvoid main() {\n\n    #include <logdepthbuf_fragment>\n\n    vec4 noise = getNoise( (worldPosition.xz) + vec2(offsetX/12.25,offsetZ/12.25) * size );\n    vec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n    vec3 diffuseLight = vec3(0.0);\n    vec3 specularLight = vec3(0.0);\n\n    vec3 worldToEye = eye-worldPosition.xyz;\n    vec3 eyeDirection = normalize( worldToEye );\n    sunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n    float distance = length(worldToEye);\n\n    vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n    vec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n    float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n    float rf0 = 0.3;\n    float reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n    vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n    vec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n    vec3 outgoingLight = albedo;\n    gl_FragColor = vec4( outgoingLight, alpha );\n\n    #include <tonemapping_fragment>\n    #include <fog_fragment>\n}\n",e.uniforms.size.value=0}),[i,a,l]),m=(0,o.useMemo)((function(){return new P.PlaneGeometry(t,t,t/4,t/4)}),[t]),p=(0,o.useMemo)((function(){return{textureWidth:256,textureHeight:256,waterNormals:u,sunDirection:new P.Vector3,side:P.DoubleSide,waterColor:"#102E4A",sunColor:"#eb8934",distortionScale:8,fog:void 0,format:s.outputEncoding,onBeforeCompile:v}}),[u,i,a,l]);return(0,o.useEffect)((function(){c.current&&(c.current.material.wireframe=n)}),[t,n,i,a,l]),(0,d.xQ)((function(e,n){if(c.current){var r=c.current.material;r.uniforms.time.value+=n,r.onBeforeCompile=v}})),(0,f.jsx)("water",{ref:c,args:[m,(0,M.Z)({},p)],"rotation-x":-Math.PI/2,position:[0,0,0]})},S=function(){var e=(0,a.M4)("Water",{size:{label:"Water Area",value:512,min:64,max:1024,step:1},wireframe:{label:"Wireframe",value:!1}}),n=e.wireframe,r=e.size,t=(0,a.M4)("Wave A",{direction:{label:"Direction",value:0,step:1,min:0,max:359},steepness:{label:"Steepness",value:.15,step:.01,min:0,max:1},wavelength:{label:"Wave Length",value:100,step:1,min:1,max:100}}),i=(0,a.M4)("Wave B",{direction:{label:"Direction",value:30,step:1,min:0,max:359},steepness:{label:"Steepness",value:.15,step:.01,min:0,max:1},wavelength:{label:"Wave Length",value:50,step:1,min:1,max:100}}),o=(0,a.M4)("Wave C",{direction:{label:"Direction",value:60,step:1,min:0,max:359},steepness:{label:"Steepness",value:.15,step:.01,min:0,max:1},wavelength:{label:"Wave Length",value:25,step:1,min:1,max:100}});return(0,f.jsx)(m,{children:(0,f.jsxs)(b,{children:[(0,f.jsx)(_,{}),(0,f.jsx)(z,{waveA:t,waveB:i,waveC:o,wireframe:n,size:r})]})})}},2410:function(e,n,r){e.exports=r.p+"static/media/waternormals.537ec85b965d414829ab.jpg"}}]);
//# sourceMappingURL=840.1d10ee80.chunk.js.map